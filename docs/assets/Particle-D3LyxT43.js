class n{constructor(i,a,l,e,t="splinter"){this.game=i,this.x=a,this.y=l,this.color=e,this.type=t,this.markedForDeletion=!1;const s=Math.random()*Math.PI*2;let h=Math.random()*100+50;this.vx=Math.cos(s)*h,this.vy=Math.sin(s)*h,this.gravity=0,this.friction=.95,t==="spark"?(this.vy=-Math.random()*100-50,this.gravity=500,this.life=.5,this.size=Math.random()*3+1):t==="splinter"?(this.gravity=0,this.life=1,this.size=Math.random()*4+2):t==="coin"?(this.state="POP",this.timer=0,this.vx=(Math.random()-.5)*300,this.vy=(Math.random()-.5)*300-200,this.gravity=800,this.life=10,this.size=8,this.friction=.9):t==="burst"?(this.life=.4,this.size=Math.random()*10+5,this.vx*=2,this.vy*=2):t==="dust"?(this.life=.5,this.size=Math.random()*8+4,this.vy=-20,this.vx*=.2,this.color="rgba(200, 200, 180, 0.5)"):(this.life=1,this.size=Math.random()*4+2),this.initialLife=this.life}update(i){this.type==="coin"?this.updateCoin(i):(this.x+=this.vx*i,this.y+=this.vy*i,this.vy+=this.gravity*i,this.vx*=this.friction,this.vy*=this.friction,this.life-=i,this.life<=0&&(this.markedForDeletion=!0))}updateCoin(i){if(this.state==="POP")this.x+=this.vx*i,this.y+=this.vy*i,this.vy+=this.gravity*i,this.y>this.game.player.y+100&&this.vy>0&&(this.vy*=-.6,this.vx*=.8),this.timer+=i,this.timer>.5&&(this.state="WAIT",this.timer=0);else if(this.state==="WAIT")this.timer+=i,this.timer>.2&&(this.state="FLY");else if(this.state==="FLY"){const e=40-this.x,t=40-this.y,s=Math.sqrt(e*e+t*t);if(s<30){this.markedForDeletion=!0;const r=this.value||1;this.game.addGold(r);return}const h=1500;this.x+=e/s*h*i,this.y+=t/s*h*i}}draw(i){i.save(),i.globalAlpha=Math.max(0,this.life/this.initialLife),this.type==="coin"&&(i.globalAlpha=1),i.fillStyle=this.color,this.type==="coin"?(i.fillStyle="#ffd700",i.shadowColor="#fea",i.shadowBlur=10,i.beginPath(),i.arc(this.x,this.y,6,0,Math.PI*2),i.fill(),i.fillStyle="#fff",i.beginPath(),i.arc(this.x-2,this.y-2,2,0,Math.PI*2),i.fill()):this.type==="spark"||this.type==="burst"||this.type==="dust"?(i.beginPath(),i.arc(this.x,this.y,this.size,0,Math.PI*2),i.fill()):(i.save(),i.translate(this.x,this.y),i.rotate(this.game.lastTime*.01+this.x),i.fillRect(-this.size/2,-this.size/2,this.size,this.size),i.restore()),i.restore()}}function f(o,i,a,l,e,t){const s=[];for(let h=0;h<e;h++){const r=new n(o,i,a,l,t);o.particles.push(r),s.push(r)}return s}export{n as Particle,f as spawnParticles};
